{"data":{"site":{"siteMetadata":{"title":"Contemplating Imponderables"}},"markdownRemark":{"id":"30cd1a0d-f09d-5622-8cea-7237d7269677","excerpt":"Largest palindrome product A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 9…","html":"<h3>Largest palindrome product</h3>\n<blockquote>\n<p>A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.\nFind the largest palindrome made from the product of two 3-digit numbers.</p>\n</blockquote>\n<p>A Palindrome! Let’s ignore spaces, punctuation, and anything else scary for now…we only care about numbers!</p>\n<p>Let’s figure out what we need to do: A palindromic number reads the same both ways.</p>\n<p>If we happen to take that at face value, we might get something along the lines of:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">isPalindrome</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> n <span class=\"token operator\">==</span> <span class=\"token string\">\"number\"</span><span class=\"token punctuation\">)</span>\n    n <span class=\"token operator\">=</span> n<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> n <span class=\"token operator\">==</span> n<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Or if we decide we will only have string inputs and we’re feeling fancy/concise, we can use a one-liner:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">isPalindrome</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> n <span class=\"token operator\">==</span> n<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>So we put our string down, split it, and reverse it. Then rejoin the array and compare it to the old one.\nLet’s just take a quick cursory examination of each of those tasks.</p>\n<ol>\n<li>Splitting the string</li>\n<li>Minimum O(n)</li>\n<li>Let’s assume we’re just splitting on \"\", the empty string. No complex regex.</li>\n<li>Reversing the array</li>\n<li>Minimum O(n)</li>\n<li>“Here’s a wrapper that indexes the array reversed so you don’t reverse the array” - No</li>\n<li>Joining the array</li>\n<li>Minimum O(n)</li>\n<li>Still need to iterate through each element to add them together.</li>\n</ol>\n<p>Do we really need to iterate through the string 3 times before we can determine whether or not it’s a palindrome?\nThat looks like complexity added through unnecessary conciseness disguised as elegance. Would it be better if we substituted the Array.prototype.split &#x26; Array.prototype.join for string iteration and concatenation? A little bit, but we can figure out something better!</p>\n<p>Let’s break it down:</p>\n<blockquote>\n<p>A palindromic number reads the same both ways</p>\n</blockquote>\n<p>We were taking the entire word, reversing it, and comparing it against itself.\nIt sounds like we don’t need to read the string more than once though…\nCan we just iterate the string and compare the paired end values? (compare the first and last, then second and second from last, etc)</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">isPalindrome</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!==</span> n<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token operator\">-</span> i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Alrighty, now we’re getting somewhere. Iterating the length of the string once. But we’re still comparing each set of values twice! We’re comparing the first and last indexes on the first and last iteration! We don’t even need to iterate through the entire string! Just iterate through half and compare to the other half; if the number has an odd number of digits then the middle value is moot because it will always be equal to itself (101, 1 == 1, 0 will always equal itself, regardless of what value it takes)!</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">isPalindrome</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> l<span class=\"token operator\">=</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>l<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!==</span> n<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token operator\">-</span> i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><a href=\"https://hodrobond.github.io/project-euler/docs/0001_0010/0004.html\">Here</a> is an example which I hope generally illustrates the difference between the first and last approaches.</p>","frontmatter":{"title":"Let's Solve Project Euler Problem 4","date":"June 14, 2017","description":"Euler Problem 4"}}},"pageContext":{"slug":"/project-euler-4/","previous":{"fields":{"slug":"/project-euler-3/"},"frontmatter":{"title":"Let's Solve Project Euler Problem 3"}},"next":{"fields":{"slug":"/project-euler-5/"},"frontmatter":{"title":"Let's Solve Project Euler Problem 5"}}}}