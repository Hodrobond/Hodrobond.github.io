<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Contemplating Imponderables]]></title><description><![CDATA[Contemplating Imponderables]]></description><link>https://gatsby-starter-blog-demo.netlify.app</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 21 Jul 2020 01:15:47 GMT</lastBuildDate><item><title><![CDATA[Let's Solve Project Euler Problem 15]]></title><description><![CDATA[Lattice paths Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down, there are exactly 6 routes…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/project-euler-15/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/project-euler-15/</guid><pubDate>Tue, 27 Jun 2017 02:00:00 GMT</pubDate><content:encoded>&lt;style&gt;
  .image-wrapper{
    text-align: center;
    display: block;
  }
&lt;/style&gt;
&lt;h3&gt;Lattice paths&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner.&lt;br/&gt;&lt;br/&gt;
&lt;span class=&quot;image-wrapper&quot;&gt;&lt;img src=&quot;https://projecteuler.net/project/images/p015.png&quot;&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;
How many such routes are there through a 20×20 grid?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Recursive:&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function countRoutes(m, n){
if(n === 0 || m === 0)
return 1;
return countRoutes(m, n - 1) + countRoutes(m - 1, n);
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Alrighty, slow as a turtle. Let’s look at this for a small m/n and see what we can figure out!&lt;br/&gt;
For &lt;code class=&quot;language-text&quot;&gt;4&lt;/code&gt; we check the routes of &lt;code class=&quot;language-text&quot;&gt;(3,2)&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;(2,3)&lt;/code&gt; which each in turn call &lt;code class=&quot;language-text&quot;&gt;(2,2)&lt;/code&gt;. Recalculation is an enemy here and it multiplies faster than bacteria, so let’s see if the mysticism of &lt;a href=&quot;https://stackoverflow.com/questions/30386943/how-to-create-a-memoize-function&quot;&gt;memoization&lt;/a&gt; can help us &lt;em&gt;magic hand wave&lt;/em&gt; away some of that tedium.&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function outerCountRoutes(m,n){
var routesArr = new Array(m+1);
for(var i=0; i&amp;#x3C;=m; i++){
routesArr[i] = new Array(n+1);
for(var j=0; j&amp;#x3C;=n; j++){
routesArr[i][j] = false;
}
}
return countRoutes(m,n);&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function countRoutes(m, n){
  if(routesArr[m][n])
    return routesArr[m][n];
  if(n === 0 || m === 0)
    return 1;
  routesArr[m][n] = countRoutes(m, n - 1) + countRoutes(m - 1, n);

  return routesArr[m][n];
}    &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  }
{% endhighlight %}&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Let's Solve Project Euler Problem 14]]></title><description><![CDATA[Longest Collatz sequence The following iterative sequence is defined for the set of positive integers:
n → n/2 (n is even)
n → 3n + 1 (n is…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/project-euler-14/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/project-euler-14/</guid><pubDate>Tue, 27 Jun 2017 01:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;Longest Collatz sequence&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The following iterative sequence is defined for the set of positive integers:&lt;br/&gt;&lt;br/&gt;
n → n/2 (n is even)&lt;br/&gt;
n → 3n + 1 (n is odd)&lt;br/&gt;&lt;br/&gt;
Using the rule above and starting with 13, we generate the following sequence:&lt;br/&gt;&lt;br/&gt;
13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1&lt;br/&gt;&lt;br/&gt;
It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.&lt;br/&gt;
Which starting number, under one million, produces the longest chain?&lt;br/&gt;
NOTE: Once the chain starts the terms are allowed to go above one million.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Brute force:&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function getCollatzChainLength(n){
var chain = [];
var chainCount = 1;
while(n !== 1){
chainCount++;
if(n%2 === 0)
n &lt;em&gt;= 0.5
else
n = 3&lt;/em&gt;n+1;
}
return chainCount;
}&lt;/p&gt;
&lt;p&gt;  function getSolution(n){
var n = 1000000;
var bestLength = 0;
var bestNum = 0;
for(var i=n; i&gt;0; i—){
var chain = getCollatzChainLength(i);
if(chain &gt; bestLength){
bestLength = chain;
bestNum = i;
}
}
return bestNum;
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Runtime (average of 100 iterations):&lt;br/&gt;
2209.2250000000004 ms&lt;/p&gt;
&lt;p&gt;Now let’s see what we can improve about this. Maybe something along the line of caching our previous Collatz lengths?&lt;br/&gt;
Let’s look at the number &lt;code class=&quot;language-text&quot;&gt;13&lt;/code&gt;, which has a length of 10. When we get to 26, we need to recalculate all 10 links of the 13 chain. That looks like it could be improved! Maybe with something like:&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
var collatzLength = [0,1];
function getCollatzChainLength(n){
if(collatzLength[n])
return collatzLength[n];
if(n%2 === 0){
var length = getCollatzChainLength(n&lt;em&gt;0.5) + 1;
collatzLength[n] = length;
return length;
}
else{
var length = getCollatzChainLength(3&lt;/em&gt;n+1) + 1;
collatzLength[n] = length;
return length;
}
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Updated runtime (average of 100 iterations):&lt;br/&gt;
1191.455 ms&lt;/p&gt;
&lt;p&gt;Well, caching was faster, let’s actually figure out a quantitative value for how many calculations we let the computer skip!&lt;br/&gt;
If we add &lt;code class=&quot;language-text&quot;&gt;var skippedLength = 0&lt;/code&gt; as a global var and update the following line:&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
if(collatzLength[n]){
skippedLength += collatzLength[n];
return collatzLength[n];&lt;br&gt;
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;We can see exactly how many chain iterations we skipped:&lt;br/&gt;&lt;code class=&quot;language-text&quot;&gt;67,631,017&lt;/code&gt;.&lt;br/&gt;How many there were total:&lt;br/&gt;&lt;code class=&quot;language-text&quot;&gt;69,799,628&lt;/code&gt;.&lt;br/&gt;Which means there was only &lt;code class=&quot;language-text&quot;&gt;2,168,611&lt;/code&gt; unique chain numbers and we skipped about 97% of recalculations!&lt;br/&gt;
If we skipped 97% of calculations, why does it still take 50%~ as long though, shouldn’t that number be closer to…3%?&lt;br/&gt;
It looks like array manipulation takes up the remainder of our boost, our chain array has a length of &lt;code class=&quot;language-text&quot;&gt;4,286,786,813&lt;/code&gt;, and manipulating arrays of that size definitely takes some effort.&lt;/p&gt;
&lt;p&gt;My Naivete is showing, nothing else is jumping at me eager for efficiency.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Let's Solve Project Euler Problem 13]]></title><description><![CDATA[Large sum Work out the first ten digits of the sum of the following one-hundred 50-digit numbers. Naturally, brute force is just adding the…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/project-euler-13/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/project-euler-13/</guid><pubDate>Sun, 25 Jun 2017 20:00:00 GMT</pubDate><content:encoded>&lt;style&gt;
  .number-block{
    text-align: center;
  }
&lt;/style&gt;
&lt;h3&gt;Large sum&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;number-block&quot;&gt;
  37107287533902102798797998220837590246510135740250
  46376937677490009712648124896970078050417018260538
  74324986199524741059474233309513058123726617309629
  91942213363574161572522430563301811072406154908250
  23067588207539346171171980310421047513778063246676
  89261670696623633820136378418383684178734361726757
  28112879812849979408065481931592621691275889832738
  44274228917432520321923589422876796487670272189318
  47451445736001306439091167216856844588711603153276
  70386486105843025439939619828917593665686757934951
  62176457141856560629502157223196586755079324193331
  64906352462741904929101432445813822663347944758178
  92575867718337217661963751590579239728245598838407
  58203565325359399008402633568948830189458628227828
  80181199384826282014278194139940567587151170094390
  35398664372827112653829987240784473053190104293586
  86515506006295864861532075273371959191420517255829
  71693888707715466499115593487603532921714970056938
  54370070576826684624621495650076471787294438377604
  53282654108756828443191190634694037855217779295145
  36123272525000296071075082563815656710885258350721
  45876576172410976447339110607218265236877223636045
  17423706905851860660448207621209813287860733969412
  81142660418086830619328460811191061556940512689692
  51934325451728388641918047049293215058642563049483
  62467221648435076201727918039944693004732956340691
  15732444386908125794514089057706229429197107928209
  55037687525678773091862540744969844508330393682126
  18336384825330154686196124348767681297534375946515
  80386287592878490201521685554828717201219257766954
  78182833757993103614740356856449095527097864797581
  16726320100436897842553539920931837441497806860984
  48403098129077791799088218795327364475675590848030
  87086987551392711854517078544161852424320693150332
  59959406895756536782107074926966537676326235447210
  69793950679652694742597709739166693763042633987085
  41052684708299085211399427365734116182760315001271
  65378607361501080857009149939512557028198746004375
  35829035317434717326932123578154982629742552737307
  94953759765105305946966067683156574377167401875275
  88902802571733229619176668713819931811048770190271
  25267680276078003013678680992525463401061632866526
  36270218540497705585629946580636237993140746255962
  24074486908231174977792365466257246923322810917141
  91430288197103288597806669760892938638285025333403
  34413065578016127815921815005561868836468420090470
  23053081172816430487623791969842487255036638784583
  11487696932154902810424020138335124462181441773470
  63783299490636259666498587618221225225512486764533
  67720186971698544312419572409913959008952310058822
  95548255300263520781532296796249481641953868218774
  76085327132285723110424803456124867697064507995236
  37774242535411291684276865538926205024910326572967
  23701913275725675285653248258265463092207058596522
  29798860272258331913126375147341994889534765745501
  18495701454879288984856827726077713721403798879715
  38298203783031473527721580348144513491373226651381
  34829543829199918180278916522431027392251122869539
  40957953066405232632538044100059654939159879593635
  29746152185502371307642255121183693803580388584903
  41698116222072977186158236678424689157993532961922
  62467957194401269043877107275048102390895523597457
  23189706772547915061505504953922979530901129967519
  86188088225875314529584099251203829009407770775672
  11306739708304724483816533873502340845647058077308
  82959174767140363198008187129011875491310547126581
  97623331044818386269515456334926366572897563400500
  42846280183517070527831839425882145521227251250327
  55121603546981200581762165212827652751691296897789
  32238195734329339946437501907836945765883352399886
  75506164965184775180738168837861091527357929701337
  62177842752192623401942399639168044983993173312731
  32924185707147349566916674687634660915035914677504
  99518671430235219628894890102423325116913619626622
  73267460800591547471830798392868535206946944540724
  76841822524674417161514036427982273348055556214818
  97142617910342598647204516893989422179826088076852
  87783646182799346313767754307809363333018982642090
  10848802521674670883215120185883543223812876952786
  71329612474782464538636993009049310363619763878039
  62184073572399794223406235393808339651327408011116
  66627891981488087797941876876144230030984490851411
  60661826293682836764744779239180335110989069790714
  85786944089552990653640447425576083659976645795096
  66024396409905389607120198219976047599490197230297
  64913982680032973156037120041377903785566085089252
  16730939319872750275468906903707539413042652315011
  94809377245048795150954100921645863754710598436791
  78639167021187492431995700641917969777599028300699
  15368713711936614952811305876380278410754449733078
  40789923115535562561142322423255033685442488917353
  44889911501440648020369068063960672322193204149535
  41503128880339536053299340368006977710650566631954
  81234880673210146739058568557934581403627822703280
  82616570773948327592232845941706525094512325230608
  22918802058777319719839450180888072429661980811197
  77158542502016545090413245809786882778948721859617
  72107838435069186155435662884062257473692284509516
  20849603980134001723930671666823555245252804609722
  53503534226472524250874054075591789781264330331690
&lt;/div&gt;
&lt;p&gt;Naturally, brute force is just adding the numbers together. Assuming the numbers are stored in an array &lt;code class=&quot;language-text&quot;&gt;arr&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
var sum = 0;
for(var i=0; i&amp;#x3C;arr.length; i++){
sum += arr[i];
}
console.log(sum);
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;And we get…5.537376230390877e+51. Well, it’s a large number. We only need the first 10 digits though, we don’t need a BigInt library yet!&lt;/p&gt;
&lt;p&gt;But we’re here to take the more difficult route which hopefully results in more fruit. Let’s look at how we might implement a bigInt add!&lt;/p&gt;
&lt;p&gt;Let’s just start with the top two numbers: &lt;code class=&quot;language-text&quot;&gt;37107287533902102798797998220837590246510135740250&lt;/code&gt;, and &lt;code class=&quot;language-text&quot;&gt;46376937677490009712648124896970078050417018260538&lt;/code&gt;, and we hope to receive &lt;code class=&quot;language-text&quot;&gt;83484225211392112511446123117807668296927154000788&lt;/code&gt;.&lt;br/&gt;
Let’s also just start with a nice, naive, elementary approach. We’ll split strings into arrays, and sum the numbers keeping track of carryovers!&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function addLargeNumbers(a,b){
var maxLength = Math.max(a.length, b.length);
var sum = new Array(maxLength);
var carryover = 0;
for(var i=0; i &amp;#x3C; maxLength; i++){
var firstNum = +a[a.length - i - 1] || 0;
var secondNum = +b[b.length - i - 1] || 0;
var tempSum = firstNum + secondNum + carryover;
carryover = tempSum &gt; 9 ? Math.floor(tempSum/10) : 0;
sum[sum.length - i - 1] = tempSum % 10;
}
if(carryover &gt; 0)
sum.unshift(carryover);&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var stringSum = &amp;quot;&amp;quot;;
for(var i=0; i&amp;lt;sum.length; i++){
  stringSum += sum[i];
}
return stringSum;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;  var a = “37107287533902102798797998220837590246510135740250”;
var b = “46376937677490009712648124896970078050417018260538”;
console.log(addLargeNumbers(a,b));
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;I was confident we could explain addition to a 6-year-old, but now it looks like we can explain it to a computer as well.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Let's Solve Project Euler Problem 12]]></title><description><![CDATA[Highly divisible triangular number The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/project-euler-12/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/project-euler-12/</guid><pubDate>Thu, 22 Jun 2017 01:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;Highly divisible triangular number&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:&lt;br/&gt;
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, …&lt;br/&gt;
Let us list the factors of the first seven triangle numbers:&lt;br/&gt;
1: 1&lt;br/&gt;
3: 1,3&lt;br/&gt;
6: 1,2,3,6&lt;br/&gt;
10: 1,2,5,10&lt;br/&gt;
15: 1,3,5,15&lt;br/&gt;
21: 1,3,7,21&lt;br/&gt;
28: 1,2,4,7,14,28&lt;br/&gt;
We can see that 28 is the first triangle number to have over five divisors.&lt;br/&gt;
What is the value of the first triangle number to have over five hundred divisors?&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Well, we have our handy-dandy getFactors function:&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function getFactors(n){
let arr = [1],
i = 2,
max = Math.floor(Math.sqrt(n));&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;while (i &amp;lt; max) {
  if (n % i === 0) {
    arr.push(i);
    let k = n / i;
    if (i !== k) {
      arr.push(k);
    }
    max = k;
  }
  i++;
}
return arr.sort((a, b) =&amp;gt; a - b);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  }
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;So what happens if we try to brute force it?&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function getSolution() {
var n = 500;
var x = 0,
y = 1;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;while (getFactors(x).length &amp;lt;= n) {
  x += y;
  y++;
}
return x&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  }
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Alright, now what’s the fun way? Is there a jetpack that can boost us to the last step? No? Alright, let’s go slowly! getFactors is fine for now, we’re only iterating until the square root of the number, not much to optimize there.&lt;/p&gt;
&lt;p&gt;There is a greener pasture, but we’re going to have to climb some hills to get there.&lt;/p&gt;
&lt;p&gt;For starters, we can write an integer $$n$$ as $$n = p&lt;em&gt;1^{a&lt;/em&gt;1} * p&lt;em&gt;2^{a&lt;/em&gt;2} * p&lt;em&gt;3^{a&lt;/em&gt;3} * …$$ where $$p&lt;em&gt;n$$ is a distinct prime number and $$a&lt;/em&gt;n$$ is the exponent.&lt;br/&gt;
For example $$28 = 4 * 7 = 2^2 * 7^1$$.&lt;br/&gt;
Additionally, the number of divisors $$D(n)$$ may be obtained from the equation: $$D(n) = (a&lt;em&gt;1+1) + (a&lt;/em&gt;2+1) + (a_3+1) + …$$&lt;br/&gt;
So for 28: $$(2+1) + (1+1) = 6$$ and we know the factors are &lt;code class=&quot;language-text&quot;&gt;[1, 2, 4, 7, 14, 28]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Since we’re dealing with primes and I’m growing tired of Eratosthenes I guess we’re going to learn about the &lt;a href=&quot;https://en.wikipedia.org/wiki/Sieve_of_Atkin&quot;&gt;Sieve of Atkin&lt;/a&gt; today too!&lt;/p&gt;
&lt;p&gt;There are three main bits of information we need to focus on, and I’ll just let &lt;a href=&quot;http://www.ams.org/journals/mcom/2004-73-246/S0025-5718-03-01501-1/S0025-5718-03-01501-1.pdf&quot;&gt;Atkin speak for himself on the validity of these statements&lt;/a&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;“All numbers n with modulo-sixty remainder 1, 13, 17, 29, 37, 41, 49, or 53 have a modulo-four remainder of 1. These numbers are prime if and only if the number of solutions to $$4x^2 + y^2 = n$$ is odd and the number is squarefree” (Theorem 6.1)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;“All numbers n with modulo-sixty remainder 7, 19, 31, or 43 have a modulo-six remainder of 1. These numbers are prime if and only if the number of solutions to $$3x^2 + y^2 = n$$ is odd and the number is squarefree” (Theorem 6.2)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;“All numbers n with modulo-sixty remainder 11, 23, 47, or 59 have a modulo-twelve remainder of 11. These numbers are prime if and only if the number of solutions to $$3x^2 − y^2 = n$$ is odd and the number is squarefree” (Theorem 6.3)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;That’s kind of a lot of moduli to consider…&lt;br/&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(i % 60 === 1) || (i % 60 === 13) || (i % 60 === 17) || (i % 60 === 29) || (i % 60 === 37) ||
(i % 60 === 41) || (i % 60 === 49) || (i % 60 === 53)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;(i % 60 === 7) || (i % 60 === 19) || (i % 60 === 31) || (i % 60 === 43)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;(i % 60 === 11) || (i % 60 === 23) || (i % 60 === 47) || (i % 60 === 59)&lt;br/&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We can consider $$n&lt;em&gt;mod(m) = r$$, r in $$R = {r : Nat0, r &amp;#x3C; m}$$, where Nat0 is the set of natural numbers beginning at 0 {0,1,2,3,…}&lt;br/&gt;
If we choose elements of R that are relatively prime to m, then every integer that satisfies the expression will be relatively prime to m or prime.&lt;br/&gt;
Relatively Prime: They share no common divisors! 4 is relatively prime to 9 ($$2^2$$ vs $$3^2$$), 9 is relative prime to 14 ($$3^2$$ vs $$2&lt;/em&gt;7$$).&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;Let’s look at our quadratics and consider the equation above, we can do some rewriting:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$$n = 4*x^2 + y^2$$.&lt;/li&gt;
&lt;li&gt;n % 60 = r where r in R1b = {r : 1, 5, 9, 13, 17, 21, 25, 29, 33, 37, 41, 45, 49, 53, 57}&lt;/li&gt;
&lt;li&gt;becomes&lt;/li&gt;
&lt;li&gt;n % 12 = r where r in R1a = {r : 1, 5, 9}&lt;/li&gt;
&lt;li&gt;$$n = 3x^2 + y^2$$.&lt;/li&gt;
&lt;li&gt;n % 60 = r where r in R2b = {r : 1, 7, 13, 19, 25, 31, 37, 43, 49, 55}&lt;/li&gt;
&lt;li&gt;becomes&lt;/li&gt;
&lt;li&gt;n % 12 = r where r in R2a = {r : 1, 7}&lt;/li&gt;
&lt;li&gt;$$n = 3x^2 - y^2$$.&lt;/li&gt;
&lt;li&gt;n % 60 = r where r in R3b = {r : 11, 23, 35, 47, 59}&lt;/li&gt;
&lt;li&gt;becomes&lt;/li&gt;
&lt;li&gt;n % 12 = r where r in R3a = {r : 11}&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now I’ve heard that we can remove some more elements from there. There appear to be &lt;a href=&quot;https://stackoverflow.com/a/12066272/3892581&quot;&gt;two large reasons for this&lt;/a&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;“Any value of r in a set R that is not relatively prime to the m with which it is paired will serve only to include values for n that are composite integers with one or more prime factors of m, none of which will be prime numbers”&lt;/li&gt;
&lt;li&gt;9 is not relatively prime to 12 ($$3^2$$ vs $$2^2 * 3$$, sharing a 3), let’s remove it&lt;/li&gt;
&lt;li&gt;“In the paper, the wheel factorizations create sets of integers that overlap, including overlapping primes. While they were convenient and the overlap didn’t matter for the theorems, in an algorithm it is wasteful if it can be easily avoided”&lt;/li&gt;
&lt;li&gt;Since 1 is already in R1a, we can remove it from R2a.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;That leaves us with:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;n % 12 = r where r in R1a = {r : 1, 5}&lt;/li&gt;
&lt;li&gt;n % 12 = r where r in R2a = {r : 7}&lt;/li&gt;
&lt;li&gt;n % 12 = r where r in R3a = {r : 11}&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Alrighty, so our sieve will look something like:&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function sievePrimesAtkin(max){
var sieve = [];
var sqrtMax = Math.sqrt(max);&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;for(var i=0; i&amp;lt;max; i++){
  sieve[i] = false;
}
sieve[0] = false;
sieve[1] = false;
sieve[2] = true;
sieve[3] = true;

for(var i=1; i&amp;lt;=sqrtMax; i++){
  for(var j=1; j&amp;lt;sqrtMax; j++){
    var n = (4 * i * i) + (j * j);
    if(n &amp;lt;= max &amp;amp;&amp;amp; (n % 12 === 1 || n % 12 === 5))
      sieve[n] = !sieve[n];
    n = (3 * i * i) + (j * j);
    if(n &amp;lt;= max &amp;amp;&amp;amp; (n % 12 === 7))
      sieve[n] = !sieve[n];
    n = (3 * i * i) - (j * j);
    if(i &amp;gt; j &amp;amp;&amp;amp; n &amp;lt;= max &amp;amp;&amp;amp; (n % 12 === 11))
      sieve[n] = !sieve[n]
  }
}
for(var i=5; i&amp;lt;=sqrtMax; i++){
  if(sieve[i]){
    var nSq = i * i;
    for(var j=nSq; j&amp;lt;=max; j+=nSq)
      sieve[j] = false;
  }
}
var primes = [];
for(var i=0; i&amp;lt;max; i++){
  if(sieve[i] === true)
    primes.push(i);
}
return primes;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  }
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Now let’s compare our runtimes, on an average of 100 runs to sieve up to 2 million I got:&lt;br/&gt;
Eratosthenes: 181.94400000000002 ms&lt;br/&gt;
Atkin: 150.14750000000004ms&lt;/p&gt;
&lt;p&gt;They’re comparable, and as it turns out Atkin is pretty reliant upon those small optimizations we made earlier. Atkin can be faster, but it takes a bit more effort and knowledge (and that’s why we’re here, aren’t we?).&lt;/p&gt;
&lt;p&gt;Some hills down, let’s start up the next. We’ve got our tools, time to combine them!&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function triangleTest(){
var t=1;
var a=1;
var count=0;
var tt, i, exponent;
var primeSieve = sievePrimesAtkin(65500);
while(count &amp;#x3C;= 500){
count = 1;
a += 1;
t += a;
tt = t;
for(var i=0; i&amp;#x3C;primeSieve.length; i++){
if(primeSieve[i] * primeSieve[i] &gt; tt){
count *= 2;
break;
}
exponent = 1;
while(tt % primeSieve[i] == 0){
exponent++;
tt = tt/primeSieve[i];
}
if(exponent &gt; 1)
count = count * exponent;
if(tt == 1)
break;
}
}
return t;
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Comparisons of runtimes:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Original brute force: 663.8050000000001 ms&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Improved with Atkin: 13.5 ms&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Can we get this better?&lt;/p&gt;
&lt;p&gt;Well we know that $$\sum_{i=1}^{n}i = \frac{n * (n+1)}{2}$$.&lt;/p&gt;
&lt;p&gt;We also know that &lt;code class=&quot;language-text&quot;&gt;n&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;n+1&lt;/code&gt; are coprime (no common prime factors). So the number of divisors may be represented as:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$$D(t) = D(\frac{n}{2}) * D(n+1)$$ if n is even&lt;/li&gt;
&lt;li&gt;$$D(t) = D(n) * D(\frac{n+1}{2})$$ if (n+1) is even&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Sounds like if we’re dealing with the divisors themselves, it should be quicker than dealing with the larger triangle numbers. We can additionally use a smaller prime number for the sieve.&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function triangleImproved() {
var n = 3;
var Dn = 2;
var primeDivisors = 2;
var count = 0;
var n1, Dn1, i, exponent;
var primeSieve = sievePrimesAtkin(1000);
while (count &amp;#x3C;= 500) {
n += 1;
n1 = n;
if (n1 % 2 === 0)
n1 = n1 / 2;
Dn1 = 1;
for (var i = 0; i &amp;#x3C; primeSieve.length; i++) {
if (primeSieve[i] * primeSieve[i] &gt; n1) {
Dn1 *= 2;
break;
}
exponent = 1;
while (n1 % primeSieve[i] === 0) {
exponent++;
n1 = n1 / primeSieve[i];
}
if (exponent &gt; 1)
Dn1 = Dn1 * exponent;
if (n1 == 1)
break;
}
count = Dn * Dn1;
Dn = Dn1;
}
return n * (n - 1) / 2;
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;For this improved version we have an average runtime of: 1.43 ms, which appears to be more than 100x faster than our initial brute force attempt.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Let's Solve Project Euler Problem 11]]></title><description><![CDATA[Largest product in a grid In the 20×20 grid below, four numbers along a diagonal line have been marked in red. I’m not fond of the words “up…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/project-euler-11/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/project-euler-11/</guid><pubDate>Tue, 20 Jun 2017 03:00:00 GMT</pubDate><content:encoded>&lt;style&gt;
  .number-block{
    text-align: center;
  }
  .red{
    color: red;
  }
  #example-anchor span{
    margin: 5px
  }

  .current{
    background: yellow;
  }

  .highest{
    background: green;
  }
&lt;/style&gt;
&lt;h3&gt;Largest product in a grid&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;In the 20×20 grid below, four numbers along a diagonal line have been marked in red.&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;number-block&quot;&gt;
08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08&lt;br/&gt;
49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00&lt;br/&gt;
81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65&lt;br/&gt;
52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91&lt;br/&gt;
22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80&lt;br/&gt;
24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50&lt;br/&gt;
32 98 81 28 64 23 67 10 &lt;span class=&quot;red&quot;&gt;26&lt;/span&gt; 38 40 67 59 54 70 66 18 38 64 70&lt;br/&gt;
67 26 20 68 02 62 12 20 95 &lt;span class=&quot;red&quot;&gt;63&lt;/span&gt; 94 39 63 08 40 91 66 49 94 21&lt;br/&gt;
24 55 58 05 66 73 99 26 97 17 &lt;span class=&quot;red&quot;&gt;78&lt;/span&gt; 78 96 83 14 88 34 89 63 72&lt;br/&gt;
21 36 23 09 75 00 76 44 20 45 35 &lt;span class=&quot;red&quot;&gt;14&lt;/span&gt; 00 61 33 97 34 31 33 95&lt;br/&gt;
78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92&lt;br/&gt;
16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57&lt;br/&gt;
86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58&lt;br/&gt;
19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40&lt;br/&gt;
04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66&lt;br/&gt;
88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69&lt;br/&gt;
04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36&lt;br/&gt;
20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16&lt;br/&gt;
20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54&lt;br/&gt;
01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48&lt;br/&gt;
&lt;/div&gt;
&gt;The product of these numbers is 26 × 63 × 78 × 14 = 1788696.
What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid?
&lt;p&gt;I’m not fond of the words “up” being paired with “down”, and “left” being paired with “right”. That sounds like a trap for over-iteration!&lt;br/&gt;
If we go through each number, we &lt;strong&gt;don’t&lt;/strong&gt; need to compare each of the 8 directions, that’s just too much. I say we only compare 4.&lt;br/&gt;
If we look at the left-most numbers on the top: 08, 49, 81, 52. We can see that comparing “down” from 08 is the same as comparing “up” from 52. The same goes for left/right, upright/downleft, and upleft/downright. We only need to pick one from each pair and we’ve got a good representation.&lt;/p&gt;
&lt;p&gt;For starters, I’d like to massage the input into a 2d array, in this example I’m assuming the input is space-separated numbers.&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function createArray(input){
var tempArr = input.split(” ”);
var length = Math.sqrt(tempArr.length);
var arr = new Array(length);
var count = 0;
for(var i=0; i&amp;#x3C;length; i++){
arr[i] = new Array(length);
for(var j=0; j&amp;#x3C;length; j++){
arr[i][j] = tempArr[count];
count++;
}
}
return arr;
}
var arrString = “08 02 22 …”
var arr2d = createArray(arrString);
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Then let’s create some helper functions for retrieving the products along those four directions we determined (Please note, the getProducts are safeguarded against accessing out-of-bounds by returning 0):&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function getRightProduct(arr, y, x){
if(x+4 &gt; arr.length)
return 0;
var product = 1;
for(var i=0; i&amp;#x3C;4; i++){
product *= arr[y][x+i];
}
return product;
}&lt;/p&gt;
&lt;p&gt;  function getDownProduct(arr, y, x){
if(y+4 &gt; arr.length)
return 0;
var product = 1;
for(var i=0; i&amp;#x3C;4; i++){
product *= arr[y+i][x];
}
return product;
}&lt;/p&gt;
&lt;p&gt;  function getDownRightProduct(arr, y, x){
if(y+4 &gt; arr.length || x+4 &gt; arr.length)
return 0;
var product = 1;
for(var i=0; i&amp;#x3C;4; i++){
product *= arr[y+i][x+i];
}
return product;
}&lt;/p&gt;
&lt;p&gt;  function getDownLeftProduct(arr, y, x){
if(y+4 &gt; arr.length || x-3 &amp;#x3C; 0)
return 0;
var product = 1;
for(var i=0; i&amp;#x3C;4; i++){
product *= arr[y+i][x-i];
}
return product;
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;And then we tie everything together:&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function getSolution(arr){
var arr = “08 02 22 …”
var arr = createArray(arr);
var highest = 0;
for(var i=0; i&amp;#x3C;arr.length; i++){
for(var j=0; j&amp;#x3C;arr[i].length; j++){
var right = getRightProduct(arr, j, i);
var down = getDownProduct(arr, j, i);
var downRight = getDownRightProduct(arr, j, i);
var downLeft = getDownLeftProduct(arr, j, i);
var tempMax = Math.max(right, down, downRight, downLeft);
highest = (tempMax &gt; highest) ? tempMax : highest;
}
}
return highest;
}
{% endhighlight %}&lt;/p&gt;
&lt;div id=&quot;example-anchor&quot; class=&quot;number-block&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;current-anchor&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;highest-anchor&quot;&gt;&lt;/div&gt;
&lt;button id=&quot;run-demo&quot;&gt;Run Demo&lt;/button&gt;
&lt;script&gt;
  function getRightProduct(arr, y, x){
    if(x+4 &gt; arr.length)
      return 0;
    var product = 1;
    for(var i=0; i&lt;4; i++){
      product *= arr[y][x+i];
    }
    return product;
  }

  function getDownProduct(arr, y, x){
    if(y+4 &gt; arr.length)
      return 0;
    var product = 1;
    for(var i=0; i&lt;4; i++){
      product *= arr[y+i][x];
    }
    return product;
  }

  function getDownRightProduct(arr, y, x){
    if(y+4 &gt; arr.length || x+4 &gt; arr.length)
      return 0;
    var product = 1;
    for(var i=0; i&lt;4; i++){
      product *= arr[y+i][x+i];
    }
    return product;
  }

  function getDownLeftProduct(arr, y, x){
    if(y+4 &gt; arr.length || x-3 &lt; 0)
      return 0;
    var product = 1;
    for(var i=0; i&lt;4; i++){
      product *= arr[y+i][x-i];
    }
    return product;
  }
  function createArray(input){
    var tempArr = input.split(&quot; &quot;);
    var length = Math.sqrt(tempArr.length);
    var arr = new Array(length);
    var count = 0;
    for(var i=0; i&lt;length; i++){
      arr[i] = new Array(length);
      for(var j=0; j&lt;length; j++){
        arr[i][j] = tempArr[count];
        count++;
      }
    }
    return arr;
  }

  var input = &quot;08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48&quot;
  var newArr = createArray(input);
  var target = document.getElementById(&quot;example-anchor&quot;);
  var row;
  for(var i=0; i&lt;newArr.length; i++){
    row = document.createElement(&quot;div&quot;);
    row.setAttribute(&apos;class&apos;, &apos;row&apos;);
    target.append(row);
    var elem;
    for(var j=0; j&lt;newArr[i].length; j++){
      elem = document.createElement(&quot;span&quot;);
      elem.setAttribute(&apos;id&apos;, &apos;num-&apos;+i+&quot;-&quot;+j);
      elem.textContent = newArr[i][j];
      row.append(elem);
    }
  }
  function runDemo(){
    var anchor = document.getElementById(&quot;example-anchor&quot;);
    var currentValue = document.getElementById(&quot;current-anchor&quot;);
    var highest = document.getElementById(&quot;highest-anchor&quot;);
    var input = &quot;08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48&quot;
    var arr = createArray(input);
    var highest = 0;
    var timer = 0;
    for(var i=0; i&lt;arr.length; i++){
      for(var j=0; j&lt;arr[i].length; j++){
        (function(i,j,timer){
          setTimeout(function(){
              var currentClasses = document.getElementsByClassName(&quot;current&quot;);
              while(currentClasses.length &gt; 0){
                currentClasses.item(0).classList.remove(&quot;current&quot;);
              }
              document.getElementById(&quot;num-&quot;+i+&quot;-&quot;+j).classList.add(&quot;current&quot;);
              var right = getRightProduct(arr, j, i);
              var down = getDownProduct(arr, j, i);
              var downRight = getDownRightProduct(arr, j, i);
              var downLeft = getDownLeftProduct(arr, j, i);
              document.getElementById(&quot;current-anchor&quot;).innerHTML = &quot;right:&quot;+right+&quot;&lt;br/&gt;&quot;+
                                                                    &quot;down:&quot;+down+&quot;&lt;br/&gt;&quot;+
                                                                    &quot;downRight:&quot;+downRight+&quot;&lt;br/&gt;&quot;+
                                                                    &quot;downLeft:&quot;+downLeft
              var tempMax = Math.max(right, down, downRight, downLeft);
              if(tempMax &gt; highest){
                var highestClasses = document.getElementsByClassName(&quot;highest&quot;);
                while(highestClasses.length &gt; 0){
                  highestClasses.item(0).classList.remove(&quot;highest&quot;);
                }
                document.getElementById(&quot;num-&quot;+i+&quot;-&quot;+j).classList.add(&quot;highest&quot;);
                switch(tempMax){
                  case right:
                    document.getElementById(&quot;num-&quot;+i+&quot;-&quot;+(j+1)).classList.add(&quot;highest&quot;);
                    document.getElementById(&quot;num-&quot;+i+&quot;-&quot;+(j+2)).classList.add(&quot;highest&quot;);
                    document.getElementById(&quot;num-&quot;+i+&quot;-&quot;+(j+3)).classList.add(&quot;highest&quot;);
                    break;
                  case down:
                    document.getElementById(&quot;num-&quot;+(i+1)+&quot;-&quot;+j).classList.add(&quot;highest&quot;);
                    document.getElementById(&quot;num-&quot;+(i+2)+&quot;-&quot;+j).classList.add(&quot;highest&quot;);
                    document.getElementById(&quot;num-&quot;+(i+3)+&quot;-&quot;+j).classList.add(&quot;highest&quot;);
                    break;
                  case downRight:
                    document.getElementById(&quot;num-&quot;+(i+1)+&quot;-&quot;+(j+1)).classList.add(&quot;highest&quot;);
                    document.getElementById(&quot;num-&quot;+(i+2)+&quot;-&quot;+(j+2)).classList.add(&quot;highest&quot;);
                    document.getElementById(&quot;num-&quot;+(i+3)+&quot;-&quot;+(j+3)).classList.add(&quot;highest&quot;);
                    break;
                  case downLeft:
                    document.getElementById(&quot;num-&quot;+(i+1)+&quot;-&quot;+(j-1)).classList.add(&quot;highest&quot;);
                    document.getElementById(&quot;num-&quot;+(i+2)+&quot;-&quot;+(j-2)).classList.add(&quot;highest&quot;);
                    document.getElementById(&quot;num-&quot;+(i+3)+&quot;-&quot;+(j- 3)).classList.add(&quot;highest&quot;);
                    break;
                }
                document.getElementById(&quot;highest-anchor&quot;).innerHTML = &quot;Highest:&quot;+tempMax;
              }
              highest = (tempMax &gt; highest) ? tempMax : highest;
            }, timer)
          })(i,j,timer)
        timer += 100;
      }
    }
    setTimeout(function(){
        var currentClasses = document.getElementsByClassName(&quot;current&quot;);
        while(currentClasses.length &gt; 0){
          currentClasses.item(0).classList.remove(&quot;current&quot;);
        }
      }, timer+50)
    return highest;
  }
  document.getElementById(&quot;run-demo&quot;).onclick = runDemo;
&lt;/script&gt;</content:encoded></item><item><title><![CDATA[Let's Solve Project Euler Problem 10]]></title><description><![CDATA[Summation of primes The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
Find the sum of all the primes below two million. Well, now I can…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/project-euler-10/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/project-euler-10/</guid><pubDate>Tue, 20 Jun 2017 02:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;Summation of primes&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
Find the sum of all the primes below two million.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Well, now I can use this without resolve, time for the &lt;a href=&quot;https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes&quot;&gt;Sieve of Eratosthenes&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function summedSievePrimes(n){
var arr = [];
var primes = [2];
for(var i=0; i&amp;#x3C;n; i++){
arr[i] = true;
}
arr[0] = false;
arr[1] = false;
arr[2] = false;
for(var i=3; i&amp;#x3C;n;i+=2){
if(arr[i] !== false){
arr[i] = false;
primes.push(i);
for(var j=i; j&amp;#x3C;n;j+=i){
arr[j] = false;
}
}
}
return primes.reduce(function(acc, val, index, arr){return acc += val});
}&lt;/p&gt;
&lt;p&gt;  console.log(sievePrimes(2000000))
{% endhighlight %}&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Let's Solve Project Euler Problem 9]]></title><description><![CDATA[Special Pythagorean triplet A Pythagorean triplet is a set of three natural numbers, $$a < b < c$$, for which,
$$a^2 + b^2 = c^2$$
For…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/project-euler-9/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/project-euler-9/</guid><pubDate>Tue, 20 Jun 2017 01:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;Special Pythagorean triplet&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;A Pythagorean triplet is a set of three natural numbers, $$a &amp;#x3C; b &amp;#x3C; c$$, for which,
$$a^2 + b^2 = c^2$$
For example, $$3^2 + 4^2 = 9 + 16 = 25 = 5^2$$.
There exists exactly one Pythagorean triplet for which $$a + b + c = 1000$$.
Find the product $$a * b * c$$.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Brute force: Iterate two loops from 1-1000. Take the square root of the sum of their squares, verify it’s a whole number. if A, B, and C sum to 1000, you’re done!&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function getSolution() {
for(var i=1; i&amp;#x3C;1000; i++){
for(var j=1; j&amp;#x3C;1000; j++){
var k = Math.sqrt(i&lt;em&gt;i+j&lt;/em&gt;j);
if( k === Math.floor(k) &amp;#x26;&amp;#x26; k&amp;#x3C;1000){
if(i+j+k === 1000){
return i&lt;em&gt;j&lt;/em&gt;k
}
}
}
}
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Elegant sidestep: $$a^2 + b^2 = c^2$$ and $$a + b + c = 1000$$ are given.&lt;br/&gt;
Let’s do a substitution for $$a=2mn$$&lt;br/&gt;
Because $$a^2 + b^2 = c^2$$ we know that $$b=m^2-n^2$$ and $$c=m^2+n^2$$&lt;br/&gt;
Because $$a + b + c = 1000$$ we can do $$2mn + (m^2 -n^2) + (m^2 + n^2) = 1000$$&lt;br/&gt;
Which boils down to $$m(m+n) = 500$$&lt;br/&gt;
Or $$n = (500/m) - m$$&lt;br/&gt;
Because $$m &gt; n$$ and neither can be negative, our solution must be $$m=20, n=5$$&lt;br/&gt;
$$a = 2mn = 2 * 20 * 5 = 200$$&lt;br/&gt;
$$b = m^2 - n^2 = 20^2 - 5^2 = 375$$&lt;br/&gt;
$$c = m^2 + n^2 = 20^2 + 5^2 = 425$$&lt;br/&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Let's Solve Project Euler Problem 8]]></title><description><![CDATA[Largest product in a series The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.
Find…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/project-euler-8/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/project-euler-8/</guid><pubDate>Mon, 19 Jun 2017 20:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;Largest product in a series&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.&lt;br/&gt;
Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;style&gt;
  .number-block{
    text-align: center;
  }

  .current{
    background: yellow;
  }

  .highest{
    background: green;
  }
&lt;/style&gt;
&lt;div class=&quot;number-block&quot;&gt;
73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450
&lt;/div&gt;
&lt;p&gt;So we want the largest product of 13 adjacent digits. This seems pretty simple, since they’re adjacent we only need to iterate the string once.
I was considering maintaining an ongoing product (if we have a large input and want to retrieve a large number of subsequent digits recalculating the product each iteration may be unnecessary), but 0 throws a monkey wrench in that plan. We’ll see if Euler forces us to revisit that.&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function getSolution(input){
var n = 13;
input = input.split(&quot;&quot;);
var currentLargest = 0;
var stack = input.slice(0,n);
var product = stack.reduce(function(acc, val, index, arr){
return acc *= val;
})
for(var i=n; i&amp;#x3C;input.length; i++){
if(product &gt; currentLargest){
currentLargest = product;
}
product = product / stack.shift();
product *= input[i];
stack.push(input[i]);
}
return currentLargest;
}&lt;/p&gt;
&lt;p&gt;{% endhighlight %}&lt;/p&gt;
&lt;div id=&quot;example-anchor&quot; class=&quot;number-block&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;current-anchor&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;answer-anchor&quot;&gt;&lt;/div&gt;
&lt;button id=&quot;run-example&quot;&gt;Show me the demo!&lt;/button&gt;
&lt;script&gt;
var input = &quot;7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450&quot;;

var rowLength = 50;
var target = document.getElementById(&quot;example-anchor&quot;);
var row;
for(var i=0; i&lt;input.length; i++){
  if( i % rowLength === 0){
    row = document.createElement(&quot;div&quot;);
    row.setAttribute(&apos;class&apos;, &apos;row&apos;);
    target.append(row);
  }
  var num = document.createElement(&quot;span&quot;);
  num.id = &quot;index-&quot;+i;
  num.textContent = input[i];
  row.append(num);
}

function runDemo(){
  var input = &quot;7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450&quot;;
  for(var i=0; i&lt;input.length; i++){
    var elem = document.getElementById(&quot;index-&quot;+i);
    elem.classList.remove(&quot;current&quot;);
    elem.classList.remove(&quot;highest&quot;);
  }
  var timer = 0;
  var n = 13;
  input = input.split(&quot;&quot;);
  var currentLargest = 0;
  var stack = input.slice(0,n);
  for(var i=0; i&lt;n; i++){
    document.getElementById(&quot;index-&quot;+i).classList.add(&quot;current&quot;);
  }
  for(var i=n; i&lt;input.length; i++){
    (function(i, timer){
      setTimeout(function(){
          var product = stack.reduce(function(acc, val, index, arr){
            return acc *= val;
          })
          document.getElementById(&quot;current-anchor&quot;).innerHTML = &quot;current:&quot;+product;
          if(product &gt; currentLargest){
            var highestClasses = document.getElementsByClassName(&quot;highest&quot;);
            while(highestClasses.length &gt; 0){
              highestClasses.item(0).classList.remove(&quot;highest&quot;);
            }
            for(var j=(i-n); j&lt;i; j++){
              document.getElementById(&quot;index-&quot;+j).classList.add(&quot;highest&quot;);
            }
            document.getElementById(&quot;answer-anchor&quot;).innerHTML = &quot;current highest:&quot;+product;
            currentLargest = product;
          }
          stack.shift();
          document.getElementById(&quot;index-&quot;+(i-n)).classList.remove(&quot;current&quot;);
          stack.push(input[i]);      
          document.getElementById(&quot;index-&quot;+i).classList.add(&quot;current&quot;);
        }, timer)
    })(i, timer);
    timer += 50;
  }
  setTimeout(function(){
    var highestClasses = document.getElementsByClassName(&quot;current&quot;);
    while(highestClasses.length &gt; 0){
      highestClasses.item(0).classList.remove(&quot;current&quot;);
    }    
  }, timer+50)

  //return currentLargest;

}

document.getElementById(&quot;run-example&quot;).onclick = runDemo;

&lt;/script&gt;</content:encoded></item><item><title><![CDATA[Let's Solve Project Euler Problem 7]]></title><description><![CDATA[10001st prime By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
What is the 10 001st…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/project-euler-7/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/project-euler-7/</guid><pubDate>Mon, 19 Jun 2017 14:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;10001st prime&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.&lt;br/&gt;
What is the 10 001st prime number?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Nothing we haven’t seen before, two immediate approaches:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Iterate and check primality&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% highlight javascript %}
function isPrime(n){
var half = Math.floor(n/2);
for(var i=2; i&amp;#x3C;=half; i++){
if(n%i === 0)
return false;
}
return true;
}&lt;/p&gt;
&lt;p&gt;  function getSolution(){
var n = 10001;
var primes = [2];
var i = 3;
while(primes.length &amp;#x3C; n){
if(isPrime(i))
primes.push(i);
i+=2;
}
return primes[primes.length - 1];
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Average of 1000 iterations is: 1139.2023500000003 ms.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes&quot;&gt;Sieve of Eratosthenes&lt;/a&gt;.
{% highlight javascript %}
function sievePrimes(n){
var arr = [];
var primes = [2];
for(var i=0; i&amp;#x3C;n; i++){
arr[i] = true;
}
arr[0] = false;
arr[1] = false;
arr[2] = false;
for(var i=3; i&amp;#x3C;n;i+=2){
if(arr[i] !== false){
arr[i] = false;
primes.push(i);
for(var j=i; j&amp;#x3C;n;j+=i){
arr[j] = false;
}
}
}
return primes;
}&lt;/p&gt;
&lt;p&gt;function getPrime(){
var primes = sievePrimes(110000);
return primes[10000];
}
{% endhighlight %}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Average of 1000 iterations: 10.9280475 ms. Please note the low bound of the sieve.&lt;br/&gt;
If we decide to increase sieve size to something we can say safely contains the prime we want (instead of a nice fairly-close bound), let’s say 1100000 (10x the initial 110000), then our new average is 106.47139999999999 ms.&lt;br/&gt;
So it looks like the Sieve is faster if we can estimate the upper-bound of the prime number reasonably well.&lt;br/&gt;
Can we estimate the upper bound of the prime to a reasonable limit?&lt;br/&gt;
&lt;a href=&quot;https://codereview.stackexchange.com/questions/90813/finding-the-nth-prime&quot;&gt;I think so!&lt;/a&gt;. It looks as simple as $$ n * (ln(n)+2) $$&lt;br/&gt;
Let’s see what that looks like and how that operates!&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function sievePrimes(n){
var arr = [];
var primes = [2];
for(var i=0; i&amp;#x3C;n; i++){
arr[i] = true;
}
arr[0] = false;
arr[1] = false;
arr[2] = false;
for(var i=3; i&amp;#x3C;n;i+=2){
if(arr[i] !== false){
arr[i] = false;
primes.push(i);
for(var j=i; j&amp;#x3C;n;j+=i){
arr[j] = false;
}
}
}
return primes;
}&lt;/p&gt;
&lt;p&gt;  function getPrime(){
var n = 10000;
var estimate = n * (Math.log(n)+2);
var primes = sievePrimes(estimate);
return primes[10000];
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;With an average run time of: 12.396499999999998 ms.&lt;br/&gt;
Alrighty, so now we can use the more efficient Sieve with a fairly accurate upper-bound on the prime numbers for an adequate runtime.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Let's Solve Project Euler Problem 6]]></title><description><![CDATA[We need MathJax Today for rendering our equations. Sum square difference The sum of the squares of the first ten natural numbers is,
12 + 2…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/project-euler-6/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/project-euler-6/</guid><pubDate>Fri, 16 Jun 2017 01:00:00 GMT</pubDate><content:encoded>&lt;p&gt;We need &lt;a href=&quot;https://www.mathjax.org/&quot;&gt;MathJax&lt;/a&gt; Today for rendering our equations.&lt;/p&gt;
&lt;h3&gt;Sum square difference&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The sum of the squares of the first ten natural numbers is,
12 + 22 + … + 102 = 385
The square of the sum of the first ten natural numbers is,
(1 + 2 + … + 10)2 = 552 = 3025
Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.
Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;First things first for 1-10:&lt;br/&gt;
Sum of Squares: &lt;code class=&quot;language-text&quot;&gt;1^2 + 2^2 + 3^2 + 4^2 + 5^2 + 6^2 + 7^2 + 8^2 + 9^2 + 10^2 = 385&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function getSumOfSquares(n){
var product = 0;
for(var i=0; i&amp;#x3C;=n; i++){
product += (i*i);
}
return product;
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Square of Sums &lt;code class=&quot;language-text&quot;&gt;(1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10)^2 = 3025&lt;/code&gt;:
{% highlight javascript %}
function getSquareOfSum(n){
var sum = 0;
for(var i=0; i&amp;#x3C;=n; i++){
sum += i;
}
return (sum*sum);
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;The brute force is pretty simple:&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function getSolution(){
var n = 100;
var sumOfSquares = getSumOfSquares(n);
var squareOfSums = getSquareOfSum(n);
return (squareOfSums - sumOfSquares);
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;But that’s not why we’re here. We want to know the magic. Please Math, tell us your secrets!&lt;/p&gt;
&lt;p&gt;We have illustrations!&lt;/p&gt;
&lt;style&gt;
  .box{
    height: 10px;
    width: 10px;
    display: inline-block;
    border: 1px solid black;
  }

  .row{
    font-size: 0;
    display: block;
  }

  .container:nth-child(2n) .row .box{
    background: blue;
  }

  .box.same{
    background: red !important;
  }

  .box.different{
    background: purple !important;
  }

  .box.someDifferent{
    background: green !important;
  }
&lt;/style&gt;
&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;
&lt;p&gt;We want the sum of all of those squares. Let’s say we have 3 coordinates: &lt;code class=&quot;language-text&quot;&gt;(a, b, c)&lt;/code&gt;.&lt;br/&gt;
&lt;code class=&quot;language-text&quot;&gt;a&lt;/code&gt; will represent which of the larger squares we are looking at (0 for the smallest, 1 for the 2x2, 2 for the 3x3, etc).&lt;br/&gt;
&lt;code class=&quot;language-text&quot;&gt;b&lt;/code&gt; will represent horizontal position within a larger square.&lt;br/&gt;
&lt;code class=&quot;language-text&quot;&gt;c&lt;/code&gt; will represent vertical position within a larger square.&lt;br/&gt;&lt;/p&gt;
&lt;div id=&quot;test2&quot;&gt;&lt;/div&gt;
&lt;p&gt;There are &lt;code class=&quot;language-text&quot;&gt;n&lt;/code&gt; positions where &lt;code class=&quot;language-text&quot;&gt;(a, b, c)&lt;/code&gt; are all equal. For our n=4 0-indexed: &lt;code class=&quot;language-text&quot;&gt;(0, 0, 0)&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;(1, 1, 1)&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;(2, 2, 2)&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;(3, 3, 3)&lt;/code&gt;.&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;button id=&quot;toggleSame&quot;&gt;Toggle Same&lt;/button&gt;&lt;/p&gt;
&lt;p&gt;There are $$2\binom{n}{3}$$ triplets where all of the entries are different.&lt;br/&gt;
&lt;button id=&quot;toggleAllDifferent&quot;&gt;Toggle All Different&lt;/button&gt;&lt;/p&gt;
&lt;p&gt;There are $$3\binom{n}{2}$$ triplets where two entries are equal and one is different.&lt;br/&gt;
&lt;button id=&quot;toggleSomeDifferent&quot;&gt;Toggle some equal&lt;/button&gt;&lt;/p&gt;
&lt;p&gt;Using our handy dandy n-choose-k equation:&lt;/p&gt;
&lt;p&gt;$$\binom{n}{k} = \frac{n\cdot(n-1)\cdots (n-k+1)}{k!} = \frac{n!}{k!(n-k)!}$$&lt;/p&gt;
&lt;p&gt;$$n + 2\binom{n}{3} + 3\binom{n}{2} = n + 2\frac{n!}{3! * (n - 3)!} + 3\frac{n!}{2! * (n - 2)!} = \frac{n(n+1)(2n+1)}{6}$$&lt;/p&gt;
&lt;p&gt;Testing that with &lt;code class=&quot;language-text&quot;&gt;n = 10&lt;/code&gt; we get the expected &lt;code class=&quot;language-text&quot;&gt;385&lt;/code&gt;. Alrighty, Sum of Squares boiled down to math.&lt;/p&gt;
&lt;p&gt;Time for the Square of Sums! Let’s start &lt;a href=&quot;https://math.stackexchange.com/a/329357&quot;&gt;here&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;$$\begin{array}{ccl}
\left(\sum\limits&lt;em&gt;{j=0}^{n-1}Z&lt;/em&gt;j\right)^2&amp;#x26;=&amp;#x26;\left(\sum\limits&lt;em&gt;{i=0}^{n-1}Z&lt;/em&gt;i\right)\left(\sum\limits&lt;em&gt;{j=0}^{n-1}Z&lt;/em&gt;j\right)\
&amp;#x26;=&amp;#x26;\sum\limits&lt;em&gt;{j=0}^{n-1}Z&lt;/em&gt;j\left(Z&lt;em&gt;j+\sum\limits&lt;/em&gt;{j\neq i}Z&lt;em&gt;i\right)\
&amp;#x26;=&amp;#x26;\sum\limits&lt;/em&gt;{j=0}^{n-1}Z&lt;em&gt;j^2+\sum\limits&lt;/em&gt;{j\neq i}Z&lt;em&gt;iZ&lt;/em&gt;j\
\end{array}
$$&lt;/p&gt;
&lt;p&gt;$$=\frac{n^2(n+1)^2}{4}$$&lt;/p&gt;
&lt;p&gt;So we can find the difference!&lt;/p&gt;
&lt;p&gt;$$\frac{n^2(n+1)^2}{4} - n + 2\frac{n!}{3! * (n - 3)!} + 3\frac{n!}{2! * (n - 2)!} = \frac{n(3n^3 + 2n^2 - 3n - 2)}{12}$$&lt;/p&gt;
&lt;p&gt;There we go, one nice equation.&lt;/p&gt;
&lt;script&gt;
  function hasClass(target, nameOfClass){
    return (&quot; &quot; + target.className + &quot; &quot;).replace(/[\n\t]/g, &quot; &quot;).indexOf(nameOfClass) &gt; -1;
  }

  function createSquares(n, anchor){
    var target = document.getElementById(anchor);
    for(var a=1; a&lt;=n; a++){
      var newContainer = document.createElement(&quot;div&quot;);
      newContainer.setAttribute(&apos;class&apos;, &apos;container&apos;);
      target.append(newContainer);
      for(var b=0; b&lt;a; b++){
        var newRow = document.createElement(&quot;div&quot;);
        newRow.setAttribute(&apos;class&apos;, &apos;row&apos;);
        newContainer.append(newRow);      
        for(var c=0; c&lt;a; c++){
          var newBox = document.createElement(&quot;div&quot;);
          newBox.setAttribute(&apos;class&apos;, &apos;box&apos;);
          newRow.append(newBox);
        }
      }
    }
  }

  function toggleSquaresSame(n, anchor){
    var target = document.getElementById(anchor);
    for(var a=0; a &lt; n; a++){
      var newContainer = target.children[a];
      for(var b=0; b&lt;=a; b++){
        var newRow = newContainer.children[b];
        for(var c=0; c&lt;=a; c++){
          var newBox = newRow.children[c];
          if(a === b &amp;&amp; a === c){
            if(hasClass(newBox, &quot;same&quot;))
              newBox.classList.remove(&apos;same&apos;);
            else
              newBox.classList.add(&apos;same&apos;);
          }
        }
      }
    }
  }

  function toggleSomeDifferent(n, anchor){
    var target = document.getElementById(anchor);
    for(var a=0; a &lt; n; a++){
      var newContainer = target.children[a];
      for(var b=0; b&lt;=a; b++){
        var newRow = newContainer.children[b];
        for(var c=0; c&lt;=a; c++){
          var newBox = newRow.children[c];
          if(a === b &amp;&amp; a !== c ||
          b === c &amp;&amp; b !== a ||
          a === c &amp;&amp; a !== b){
            if(hasClass(newBox, &quot;someDifferent&quot;))
              newBox.classList.remove(&apos;someDifferent&apos;);
            else
              newBox.classList.add(&apos;someDifferent&apos;);            
          }
        }
      }
    }
  }

  function toggleAllDifferent(n, anchor){
    var target = document.getElementById(anchor);
    for(var a=0; a &lt; n; a++){
      var newContainer = target.children[a];
      for(var b=0; b&lt;=a; b++){
        var newRow = newContainer.children[b];
        for(var c=0; c&lt;=a; c++){
          var newBox = newRow.children[c];
          if(a !== b &amp;&amp; a !== c &amp;&amp; b !== c){
            if(hasClass(newBox, &quot;different&quot;))
              newBox.classList.remove(&apos;different&apos;);
            else
              newBox.classList.add(&apos;different&apos;);
          }
        }
      }
    }
  }

  createSquares(4, &quot;test&quot;);
  createSquares(4, &quot;test2&quot;);
  document.getElementById(&quot;toggleSame&quot;).onclick = function(){
    toggleSquaresSame(4, &quot;test2&quot;);
  }
  document.getElementById(&quot;toggleSomeDifferent&quot;).onclick = function(){
    toggleSomeDifferent(4, &quot;test2&quot;);
  }

  document.getElementById(&quot;toggleAllDifferent&quot;).onclick = function(){
    toggleAllDifferent(4, &quot;test2&quot;);
  }


&lt;/script&gt;</content:encoded></item><item><title><![CDATA[Let's Solve Project Euler Problem 5]]></title><description><![CDATA[Smallest multiple 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
What is the…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/project-euler-5/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/project-euler-5/</guid><pubDate>Thu, 15 Jun 2017 02:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;Smallest multiple&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Brute Force:&lt;br/&gt;
Iterate i to n until a number is divisible by 1-20! Let’s test it with our sample input first, the numbers up to 10.&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function getLowest(){
var limit = 10;
while(true){
for(var j=1; j&amp;#x3C;=limit; j++){
if(i%j !== 0)
break;
if(j === limit)
return i;
}
}
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Well. It works! Slowly, but surely. If we want to find the numbers divisible by 1-40 we may very well be waiting until the heat death of the universe. There’s nothing inherently &lt;em&gt;wrong&lt;/em&gt; with this approach per se. If I forgot someone’s phone number I &lt;em&gt;could&lt;/em&gt; call every phone number until I find them, it’ll take a while but it’ll work.&lt;/p&gt;
&lt;p&gt;Alright we learned something related to this a long time ago, many moons ago…likely back in grade school.
What were they called…ah yes, &lt;em&gt;Prime Factors&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Ah forget it, I don’t remember why they were important, skipping to the solution is no fun anyhow. Let’s try to reason it out, starting with a smaller number!&lt;/p&gt;
&lt;p&gt;So the number &lt;code class=&quot;language-text&quot;&gt;20&lt;/code&gt; has the prime factors &lt;br/&gt;&lt;code class=&quot;language-text&quot;&gt;[ 2, 2, 5 ]&lt;/code&gt;.&lt;br/&gt;It has the factors &lt;br/&gt;&lt;code class=&quot;language-text&quot;&gt;[ 2, 4, 5, 10 ]&lt;/code&gt;.&lt;br/&gt;
Interesting. It looks like every &lt;em&gt;Factor&lt;/em&gt; can be expressed through products of one or more &lt;em&gt;Prime Factors&lt;/em&gt;.&lt;br/&gt;
&lt;code class=&quot;language-text&quot;&gt;10 = 2 * 5&lt;/code&gt;&lt;br/&gt;
&lt;code class=&quot;language-text&quot;&gt;5 = 5&lt;/code&gt;&lt;br/&gt;
&lt;code class=&quot;language-text&quot;&gt;4 = 2 * 2&lt;/code&gt;&lt;br/&gt;
&lt;code class=&quot;language-text&quot;&gt;2 = 2&lt;/code&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;Alright, that looks promising, let’s see if it is true for the answer we know.
The prime factors of &lt;code class=&quot;language-text&quot;&gt;2520&lt;/code&gt; are&lt;br/&gt;&lt;code class=&quot;language-text&quot;&gt;[ 2, 2, 2, 3, 3, 5, 7 ]&lt;/code&gt;&lt;br/&gt;with factors of &lt;br/&gt;&lt;code class=&quot;language-text&quot;&gt;[2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 18, 20, 21, 24, 28, 30, 35, 36, 40, 42, 45, 56, 60, 63, 70, 72, 84, 90, 105, 120, 126, 140, 168, 180, 210, 252, 280, 315, 360, 420, 504, 630, 840, 1260 ]&lt;/code&gt;.&lt;br/&gt;Well, it looks like every factor can still be represented through one or more products of prime factors.&lt;/p&gt;
&lt;p&gt;Now that information sounds interesting, but is it useful? Let’s look at the prime factors of &lt;code class=&quot;language-text&quot;&gt;2-10&lt;/code&gt;.&lt;br/&gt;
2: &lt;code class=&quot;language-text&quot;&gt;[2]&lt;/code&gt;&lt;br/&gt;
3: &lt;code class=&quot;language-text&quot;&gt;[3]&lt;/code&gt;&lt;br/&gt;
4: &lt;code class=&quot;language-text&quot;&gt;[2, 2]&lt;/code&gt;&lt;br/&gt;
5: &lt;code class=&quot;language-text&quot;&gt;[5]&lt;/code&gt;&lt;br/&gt;
6: &lt;code class=&quot;language-text&quot;&gt;[2, 3]&lt;/code&gt;&lt;br/&gt;
7: &lt;code class=&quot;language-text&quot;&gt;[7]&lt;/code&gt;&lt;br/&gt;
8: &lt;code class=&quot;language-text&quot;&gt;[2, 2, 2]&lt;/code&gt;&lt;br/&gt;
9: &lt;code class=&quot;language-text&quot;&gt;[3, 3]&lt;/code&gt;&lt;br/&gt;
10: &lt;code class=&quot;language-text&quot;&gt;[2, 5]&lt;/code&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;Let’s see what happens if we put the unique prime factors of &lt;code class=&quot;language-text&quot;&gt;2-10&lt;/code&gt; together.&lt;br/&gt;
&lt;code class=&quot;language-text&quot;&gt;[ 2, 2, 2, 3, 3, 5, 7 ]&lt;/code&gt;&lt;br/&gt;
Suspicious…and if we multiply all the unique prime factors together, we get 2520.&lt;/p&gt;
&lt;p&gt;Well, it looks like if we take the collection of unique prime numbers (&lt;code class=&quot;language-text&quot;&gt;[2, 3]&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;[2, 2]&lt;/code&gt; becomes &lt;code class=&quot;language-text&quot;&gt;[2, 2, 3]&lt;/code&gt;) then we’ve got a representation of the smallest number divisible by all of the elements.&lt;/p&gt;
&lt;p&gt;So what might the code look like?&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function getSolution(){&lt;br&gt;
var n = 20;
var factors = [];
for(var i=2; i&amp;#x3C;=n; i++){
var fact = getPrimeFactors(i);
var tempFactors = factors.slice();
for(var j=0; j&amp;#x3C;fact.length;j++){
var index = tempFactors.indexOf(fact[j]);
if(index &gt; -1){
tempFactors.splice(index,1);
}
else{
factors.push(fact[j]);
}
}
}
return factors.reduce(function(acc, val, index, arr){
return acc * val;
});
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Store all the unique factors in an array, get the product using an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce?v=control&quot;&gt;Array.prototype.reduce&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;“I’ll never use this in my life!” I exclaimed while learning prime factors. Good thing I remembered it, turned out to be fun.&lt;/p&gt;
&lt;p&gt;I wonder what else I was missing out on…&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Let's Solve Project Euler Problem 4]]></title><description><![CDATA[Largest palindrome product A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/project-euler-4/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/project-euler-4/</guid><pubDate>Wed, 14 Jun 2017 20:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;Largest palindrome product&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
Find the largest palindrome made from the product of two 3-digit numbers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A Palindrome! Let’s ignore spaces, punctuation, and anything else scary for now…we only care about numbers!&lt;/p&gt;
&lt;p&gt;Let’s figure out what we need to do: A palindromic number reads the same both ways.&lt;/p&gt;
&lt;p&gt;If we happen to take that at face value, we might get something along the lines of:&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function isPalindrome(n){
if(typeof n == “number”)
n = n.toString();
return n == n.split(&quot;&quot;).reverse().join(&quot;&quot;);
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Or if we decide we will only have string inputs and we’re feeling fancy/concise, we can use a one-liner:
{% highlight javascript %}
const isPalindrome = (n) =&gt; {return n == n.split(&quot;&quot;).reverse().join(&quot;&quot;);}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;So we put our string down, split it, and reverse it. Then rejoin the array and compare it to the old one.
Let’s just take a quick cursory examination of each of those tasks.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Splitting the string&lt;/li&gt;
&lt;li&gt;Minimum O(n)&lt;/li&gt;
&lt;li&gt;Let’s assume we’re just splitting on &quot;&quot;, the empty string. No complex regex.&lt;/li&gt;
&lt;li&gt;Reversing the array&lt;/li&gt;
&lt;li&gt;Minimum O(n)&lt;/li&gt;
&lt;li&gt;“Here’s a wrapper that indexes the array reversed so you don’t reverse the array” - No&lt;/li&gt;
&lt;li&gt;Joining the array&lt;/li&gt;
&lt;li&gt;Minimum O(n)&lt;/li&gt;
&lt;li&gt;Still need to iterate through each element to add them together.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Do we really need to iterate through the string 3 times before we can determine whether or not it’s a palindrome?
That looks like complexity added through unnecessary conciseness disguised as elegance. Would it be better if we substituted the Array.prototype.split &amp;#x26; Array.prototype.join for string iteration and concatenation? A little bit, but we can figure out something better!&lt;/p&gt;
&lt;p&gt;Let’s break it down:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A palindromic number reads the same both ways&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We were taking the entire word, reversing it, and comparing it against itself.
It sounds like we don’t need to read the string more than once though…
Can we just iterate the string and compare the paired end values? (compare the first and last, then second and second from last, etc)&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function isPalindrome(n){
for(var i=0; i&amp;#x3C;n.length - 1; i++){
if(n[i] !== n[n.length - 1 - i])
return false;
}
return true;
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Alrighty, now we’re getting somewhere. Iterating the length of the string once. But we’re still comparing each set of values twice! We’re comparing the first and last indexes on the first and last iteration! We don’t even need to iterate through the entire string! Just iterate through half and compare to the other half; if the number has an odd number of digits then the middle value is moot because it will always be equal to itself (101, 1 == 1, 0 will always equal itself, regardless of what value it takes)!&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function isPalindrome(n){
for(var i=0, l=Math.floor(n/2); i&amp;#x3C;l; i++){
if(n[i] !== n[n.length - 1 - i])
return false;
}
return true;
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hodrobond.github.io/project-euler/docs/0001_0010/0004.html&quot;&gt;Here&lt;/a&gt; is an example which I hope generally illustrates the difference between the first and last approaches.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Let's Solve Project Euler Problem 3]]></title><description><![CDATA[Wow, THREE posts in one day? Largest prime factor The prime factors of 13195 are 5, 7, 13 and 29.
What is the largest prime factor of the…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/project-euler-3/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/project-euler-3/</guid><pubDate>Tue, 13 Jun 2017 20:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Wow, &lt;em&gt;THREE&lt;/em&gt; posts in one day?&lt;/p&gt;
&lt;h3&gt;Largest prime factor&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The prime factors of 13195 are 5, 7, 13 and 29.&lt;br/&gt;
What is the largest prime factor of the number 600851475143 ?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Well, 600851475143 is a pretty large number, but it doesn’t require any special coercions yet. 12 digits is reasonable.&lt;/p&gt;
&lt;h4&gt;The Fool begins his journey&lt;/h4&gt;
&lt;p&gt;Oh, Oh, I know, I know! Let’s just do an iteration, modulus, check primality, and store the highest! Maybe something like…&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function isPrime(n){
for(var i=2; i&amp;#x3C;n; i++){
if(n % i === 0)
return false
}
return true;
}
function getLargestPrimeFactor(n){
var largest = 0;
for(var i=0; i&amp;#x3C;n; i++){
if(n % i === 0 &amp;#x26;&amp;#x26; isPrime(i))
largest = i;
}
return largest;
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Alrighty, let’s try a smaller input we’re aware of the answer for: 13195.&lt;/p&gt;
&lt;p&gt;The average from 100 iterations took
0.21744999999999962 ms&lt;/p&gt;
&lt;p&gt;Well, that’s taking quite a while and we still have 7 more digits to add! Let’s see if we can find something better!&lt;/p&gt;
&lt;h4&gt;The Fool meets the Magician&lt;/h4&gt;
&lt;p&gt;Let’s try using that &lt;a href=&quot;https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes&quot;&gt;Sieve of Eratosthenes&lt;/a&gt; I like so much. Will the right tool help?&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function sievePrimes(n){
var arr = [];
var primes = [2];
for(var i=0; i&amp;#x3C;n; i++){
arr[i] = true;
}
arr[0] = false;
arr[1] = false;
arr[2] = false;
for(var i=3; i&amp;#x3C;n;i+=2){
if(arr[i] !== false){
arr[i] = false;
primes.push(i);
for(var j=i; j&amp;#x3C;n;j+=i){
arr[j] = false;
}
}
}&lt;br&gt;
return primes;
}
var primes = sievePrimes(2000000);
function isPrime(n){
for(var i=0; i&amp;#x3C;primes.length; i++){
if(primes[i] === n)
return true;
if(primes[i] &gt; n)
return false;
}
return false;
}&lt;/p&gt;
&lt;p&gt;  function getLargestPrimeFactor(n){
var largest = 0;
for(var i=0; i&amp;#x3C;n; i++){
if(n % i === 0 &amp;#x26;&amp;#x26; isPrime(i))
largest = i;
}
return largest;
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;the average iteration from 100 took:
0.14749999999999885 ms&lt;/p&gt;
&lt;p&gt;Alrighty. We’ve got an improvement on our small N. We’ve also tackled the issue of determining primality for larger numbers which will become evident with larger inputs.&lt;/p&gt;
&lt;h4&gt;The Fool meets the High Priestess&lt;/h4&gt;
&lt;p&gt;Let’s calm down, take a step back and figure out what we actually want.
The largest prime factor. So we need to find primes and determine if they are factors, or find factors and determine if they are prime…right?
Why not just find the prime factors directly?&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function getSolution(){
var n = 600851475143;
var half = Math.floor(n/2);
for(var i=2; i&amp;#x3C;half; i++){
if(n%i === 0){
//divide the number by the factor
n = n/i;
//The last factor will be the largest
if(n === 1)
return i;
i—; //make sure duplicate factors are caught
}
}
}
{% endhighlight %}&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Iterate up until half of the number.&lt;/li&gt;
&lt;li&gt;There is no way ∃ n ∋ k/2 &amp;#x3C; n &amp;#x3C; k &amp;#x26;&amp;#x26; k % n == 0 where n and k are integers.&lt;/li&gt;
&lt;li&gt;i will iterate until half of n, bumping into all of the factors along the way.&lt;/li&gt;
&lt;li&gt;Starting the count at 2, we ensure all the small primes are removed first. 10/2 == 5.&lt;/li&gt;
&lt;li&gt;Removing factors significantly reduces the number of iterations required (10000 / 2 == 5000, we’ve already split the numbers we must iterate through in half!)&lt;/li&gt;
&lt;li&gt;By removing every factor incrementally, we can ensure there is no smaller i for which n is divisible. 20 is divisible by 10, but it’s also divisible by 2. 20 / 2 == 10 —&gt; 10 / 2 == 5 —&gt; any non-prime number won’t appear.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For the same input (13195), the average iteration took:
0.0012000000000000454 ms&lt;/p&gt;
&lt;p&gt;Well, that’s an entirely different tier of improvement!&lt;/p&gt;
&lt;p&gt;Let’s try it with our large input (600851475143).
average iteration:
0.1238499999999999 ms&lt;/p&gt;
&lt;p&gt;Well it looks like our final solution works faster on the 12 digit input than our initial solution did on the 5 digit input. I’ll call that an improvement.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Let's Solve Project Euler Problem 2]]></title><description><![CDATA[Wow, two posts in one day. I’m energetic, aren’t I? Let’s get into problem 2 Even Fibonacci numbers Each new term in the Fibonacci sequence…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/project-euler-2/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/project-euler-2/</guid><pubDate>Tue, 13 Jun 2017 20:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Wow, two posts in one day. I’m energetic, aren’t I?&lt;/p&gt;
&lt;p&gt;Let’s get into problem 2&lt;/p&gt;
&lt;h3&gt;Even Fibonacci numbers&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:&lt;br/&gt;
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …&lt;br/&gt;
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;As is the pattern with Project Euler, there are a myriad of ways we can solve this problem.&lt;/p&gt;
&lt;p&gt;The Fibonnaci sequence is generally used to teach recursion. Maybe something along the lines of&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function fibonacci(n) {
if (n === 1){
return 1;
}else{
return fibonacci(n-2) + fibonacci(n-1);
}
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;or if you’re fancy:&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
function fibonacci(n) {
return (n === 1) ? 1 : fibonacci(n-2) + fibonacci(n-1);
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Ignoring the call stack issues for larger numbers we can solve using setTimeout, retrieving all of the subsequent fibonacci numbers this way seems…inefficient. If I get the 6th fibonacci number then the 7th, it will recalculate all of the previous numbers.&lt;/p&gt;
&lt;p&gt;I propose an iterative solution. Keeping track of the current and previous fibonacci numbers (I love the &lt;a href=&quot;https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes&quot;&gt;Sieve of Eratosthenes&lt;/a&gt; but it just doesn’t cut it here. We won’t know the maximum value of the prime we need unless we do some intricate mathematical analysis or by testing to get the value explicitly)&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
var maxFibonacciValue = 4000000;
var prev = 1;
var current = 2;
var sum = current;
var temp;
//iterative over recursive fibonacci.
while(sum &amp;#x3C; maxFibonacciValue){
temp = current;
current += prev;
prev = temp;
if(current % 2 === 0)
sum += current
}
return sum;
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;We don’t actually have any use for any fibonacci number other than “is this one even? Let’s add it to the sum” and “Let’s add the last one to this one to get the next one!“.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Let's Solve Project Euler Problem 1]]></title><description><![CDATA[Hello probably me again. Still looking back in time. Today I am interested in explaining to myself why Project Euler is so fun! The short…]]></description><link>https://gatsby-starter-blog-demo.netlify.app/project-euler-1/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.app/project-euler-1/</guid><pubDate>Tue, 13 Jun 2017 16:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Hello probably me again. Still looking back in time.&lt;/p&gt;
&lt;p&gt;Today I am interested in explaining to myself why &lt;a href=&quot;https://projecteuler.net/&quot;&gt;Project Euler&lt;/a&gt; is so fun!&lt;/p&gt;
&lt;p&gt;The short answer is: “Math”.&lt;br&gt;
The long answer is: “Different Math”.&lt;/p&gt;
&lt;p&gt;Let’s begin with problem 1:&lt;/p&gt;
&lt;h3&gt;Multiples of 3 and 5&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below 1000.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;There are two immediately obvious approaches.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Iterate from 1-1000 (exclusive), modulus, and sum&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Iterates once through all the items&lt;/li&gt;
&lt;li&gt;Checks modulus of 3 &amp;#x26;&amp;#x26; 5 on each element&lt;/li&gt;
&lt;li&gt;Sums as we proceed&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Create an array, iterate by increments of 3/5 (marking the increments), then summing the marked elements.&lt;/li&gt;
&lt;li&gt;Iterates once by 3’s, once by 5’s, then once by 1’s&lt;/li&gt;
&lt;li&gt;Sum on last iteration&lt;/li&gt;
&lt;li&gt;Requires an additional array.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://hodrobond.github.io/project-euler/docs/0001_0010/0001.html&quot;&gt;Here&lt;/a&gt; is a link to the two functions running with a slight delay so the execution is observable.&lt;/p&gt;
&lt;p&gt;From inspection, it looks like #1 will run faster, let’s see if I’m right using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Performance/now&quot;&gt;performance.now()&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Running attempt #1 1000 times and taking the average resulted in: 0.004790000021457672 ms&lt;/p&gt;
&lt;p&gt;  {% highlight javascript %}
var sum = 0;
for(var i=0; i&amp;#x3C; 1000; i++){
if(i % 5 === 0 || i % 3 === 0){
sum += i;
}
}
return sum
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Running attempt #2 1000 times and taking the average resulted in: 0.04011499987542629 ms&lt;/p&gt;
&lt;p&gt;{% highlight javascript %}
var arr = [];
var sum = 0;
for(var i=3; i&amp;#x3C;1000; i+=3){
arr[i] = true;
}
for(var i=5; i&amp;#x3C;1000; i+=5){
arr[i] = true;
}
for(var i=0; i&amp;#x3C;1000; i++){
if(arr[i] === true)
sum += i;
}
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;So it looks like our first attempt was quicker by a factor of about &lt;em&gt;10x&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Alright. This was probably a bad example where immediate intuition resulted in an appropriate solution. I promise the other ones are more fun…&lt;/p&gt;</content:encoded></item></channel></rss>