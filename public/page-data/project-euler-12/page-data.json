{"componentChunkName":"component---src-templates-blog-post-js","path":"/project-euler-12/","result":{"data":{"site":{"siteMetadata":{"title":"Contemplating Imponderables"}},"markdownRemark":{"id":"4ccfda89-9c84-5dd3-9135-9af019a07eba","excerpt":"Highly divisible triangular number The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 +…","html":"<h3>Highly divisible triangular number</h3>\n<blockquote>\n<p>The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:<br/>\n1, 3, 6, 10, 15, 21, 28, 36, 45, 55, …<br/>\nLet us list the factors of the first seven triangle numbers:<br/>\n1: 1<br/>\n3: 1,3<br/>\n6: 1,2,3,6<br/>\n10: 1,2,5,10<br/>\n15: 1,3,5,15<br/>\n21: 1,3,7,21<br/>\n28: 1,2,4,7,14,28<br/>\nWe can see that 28 is the first triangle number to have over five divisors.<br/>\nWhat is the value of the first triangle number to have over five hundred divisors?<br/></p>\n</blockquote>\n<p>Well, we have our handy-dandy getFactors function:</p>\n<p>{% highlight javascript %}\nfunction getFactors(n){\nlet arr = [1],\ni = 2,\nmax = Math.floor(Math.sqrt(n));</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">while (i &lt; max) {\n  if (n % i === 0) {\n    arr.push(i);\n    let k = n / i;\n    if (i !== k) {\n      arr.push(k);\n    }\n    max = k;\n  }\n  i++;\n}\nreturn arr.sort((a, b) =&gt; a - b);</code></pre></div>\n<p>  }\n{% endhighlight %}</p>\n<p>So what happens if we try to brute force it?</p>\n<p>{% highlight javascript %}\nfunction getSolution() {\nvar n = 500;\nvar x = 0,\ny = 1;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">while (getFactors(x).length &lt;= n) {\n  x += y;\n  y++;\n}\nreturn x</code></pre></div>\n<p>  }\n{% endhighlight %}</p>\n<p>Alright, now what’s the fun way? Is there a jetpack that can boost us to the last step? No? Alright, let’s go slowly! getFactors is fine for now, we’re only iterating until the square root of the number, not much to optimize there.</p>\n<p>There is a greener pasture, but we’re going to have to climb some hills to get there.</p>\n<p>For starters, we can write an integer $$n$$ as $$n = p<em>1^{a</em>1} * p<em>2^{a</em>2} * p<em>3^{a</em>3} * …$$ where $$p<em>n$$ is a distinct prime number and $$a</em>n$$ is the exponent.<br/>\nFor example $$28 = 4 * 7 = 2^2 * 7^1$$.<br/>\nAdditionally, the number of divisors $$D(n)$$ may be obtained from the equation: $$D(n) = (a<em>1+1) + (a</em>2+1) + (a_3+1) + …$$<br/>\nSo for 28: $$(2+1) + (1+1) = 6$$ and we know the factors are <code class=\"language-text\">[1, 2, 4, 7, 14, 28]</code></p>\n<p>Since we’re dealing with primes and I’m growing tired of Eratosthenes I guess we’re going to learn about the <a href=\"https://en.wikipedia.org/wiki/Sieve_of_Atkin\">Sieve of Atkin</a> today too!</p>\n<p>There are three main bits of information we need to focus on, and I’ll just let <a href=\"http://www.ams.org/journals/mcom/2004-73-246/S0025-5718-03-01501-1/S0025-5718-03-01501-1.pdf\">Atkin speak for himself on the validity of these statements</a>:</p>\n<ol>\n<li>\n<blockquote>\n<p>“All numbers n with modulo-sixty remainder 1, 13, 17, 29, 37, 41, 49, or 53 have a modulo-four remainder of 1. These numbers are prime if and only if the number of solutions to $$4x^2 + y^2 = n$$ is odd and the number is squarefree” (Theorem 6.1)</p>\n</blockquote>\n</li>\n<li>\n<blockquote>\n<p>“All numbers n with modulo-sixty remainder 7, 19, 31, or 43 have a modulo-six remainder of 1. These numbers are prime if and only if the number of solutions to $$3x^2 + y^2 = n$$ is odd and the number is squarefree” (Theorem 6.2)</p>\n</blockquote>\n</li>\n<li>\n<blockquote>\n<p>“All numbers n with modulo-sixty remainder 11, 23, 47, or 59 have a modulo-twelve remainder of 11. These numbers are prime if and only if the number of solutions to $$3x^2 − y^2 = n$$ is odd and the number is squarefree” (Theorem 6.3)</p>\n</blockquote>\n</li>\n</ol>\n<p>That’s kind of a lot of moduli to consider…<br/></p>\n<ol>\n<li>(i % 60 === 1) || (i % 60 === 13) || (i % 60 === 17) || (i % 60 === 29) || (i % 60 === 37) ||\n(i % 60 === 41) || (i % 60 === 49) || (i % 60 === 53)<br/></li>\n<li>(i % 60 === 7) || (i % 60 === 19) || (i % 60 === 31) || (i % 60 === 43)<br/></li>\n<li>(i % 60 === 11) || (i % 60 === 23) || (i % 60 === 47) || (i % 60 === 59)<br/></li>\n</ol>\n<p>We can consider $$n<em>mod(m) = r$$, r in $$R = {r : Nat0, r &#x3C; m}$$, where Nat0 is the set of natural numbers beginning at 0 {0,1,2,3,…}<br/>\nIf we choose elements of R that are relatively prime to m, then every integer that satisfies the expression will be relatively prime to m or prime.<br/>\nRelatively Prime: They share no common divisors! 4 is relatively prime to 9 ($$2^2$$ vs $$3^2$$), 9 is relative prime to 14 ($$3^2$$ vs $$2</em>7$$).<br/></p>\n<p>Let’s look at our quadratics and consider the equation above, we can do some rewriting:</p>\n<ol>\n<li>$$n = 4*x^2 + y^2$$.</li>\n<li>n % 60 = r where r in R1b = {r : 1, 5, 9, 13, 17, 21, 25, 29, 33, 37, 41, 45, 49, 53, 57}</li>\n<li>becomes</li>\n<li>n % 12 = r where r in R1a = {r : 1, 5, 9}</li>\n<li>$$n = 3x^2 + y^2$$.</li>\n<li>n % 60 = r where r in R2b = {r : 1, 7, 13, 19, 25, 31, 37, 43, 49, 55}</li>\n<li>becomes</li>\n<li>n % 12 = r where r in R2a = {r : 1, 7}</li>\n<li>$$n = 3x^2 - y^2$$.</li>\n<li>n % 60 = r where r in R3b = {r : 11, 23, 35, 47, 59}</li>\n<li>becomes</li>\n<li>n % 12 = r where r in R3a = {r : 11}</li>\n</ol>\n<p>Now I’ve heard that we can remove some more elements from there. There appear to be <a href=\"https://stackoverflow.com/a/12066272/3892581\">two large reasons for this</a>:</p>\n<ol>\n<li>“Any value of r in a set R that is not relatively prime to the m with which it is paired will serve only to include values for n that are composite integers with one or more prime factors of m, none of which will be prime numbers”</li>\n<li>9 is not relatively prime to 12 ($$3^2$$ vs $$2^2 * 3$$, sharing a 3), let’s remove it</li>\n<li>“In the paper, the wheel factorizations create sets of integers that overlap, including overlapping primes. While they were convenient and the overlap didn’t matter for the theorems, in an algorithm it is wasteful if it can be easily avoided”</li>\n<li>Since 1 is already in R1a, we can remove it from R2a.</li>\n</ol>\n<p>That leaves us with:</p>\n<ol>\n<li>n % 12 = r where r in R1a = {r : 1, 5}</li>\n<li>n % 12 = r where r in R2a = {r : 7}</li>\n<li>n % 12 = r where r in R3a = {r : 11}</li>\n</ol>\n<p>Alrighty, so our sieve will look something like:</p>\n<p>{% highlight javascript %}\nfunction sievePrimesAtkin(max){\nvar sieve = [];\nvar sqrtMax = Math.sqrt(max);</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for(var i=0; i&lt;max; i++){\n  sieve[i] = false;\n}\nsieve[0] = false;\nsieve[1] = false;\nsieve[2] = true;\nsieve[3] = true;\n\nfor(var i=1; i&lt;=sqrtMax; i++){\n  for(var j=1; j&lt;sqrtMax; j++){\n    var n = (4 * i * i) + (j * j);\n    if(n &lt;= max &amp;&amp; (n % 12 === 1 || n % 12 === 5))\n      sieve[n] = !sieve[n];\n    n = (3 * i * i) + (j * j);\n    if(n &lt;= max &amp;&amp; (n % 12 === 7))\n      sieve[n] = !sieve[n];\n    n = (3 * i * i) - (j * j);\n    if(i &gt; j &amp;&amp; n &lt;= max &amp;&amp; (n % 12 === 11))\n      sieve[n] = !sieve[n]\n  }\n}\nfor(var i=5; i&lt;=sqrtMax; i++){\n  if(sieve[i]){\n    var nSq = i * i;\n    for(var j=nSq; j&lt;=max; j+=nSq)\n      sieve[j] = false;\n  }\n}\nvar primes = [];\nfor(var i=0; i&lt;max; i++){\n  if(sieve[i] === true)\n    primes.push(i);\n}\nreturn primes;</code></pre></div>\n<p>  }\n{% endhighlight %}</p>\n<p>Now let’s compare our runtimes, on an average of 100 runs to sieve up to 2 million I got:<br/>\nEratosthenes: 181.94400000000002 ms<br/>\nAtkin: 150.14750000000004ms</p>\n<p>They’re comparable, and as it turns out Atkin is pretty reliant upon those small optimizations we made earlier. Atkin can be faster, but it takes a bit more effort and knowledge (and that’s why we’re here, aren’t we?).</p>\n<p>Some hills down, let’s start up the next. We’ve got our tools, time to combine them!</p>\n<p>{% highlight javascript %}\nfunction triangleTest(){\nvar t=1;\nvar a=1;\nvar count=0;\nvar tt, i, exponent;\nvar primeSieve = sievePrimesAtkin(65500);\nwhile(count &#x3C;= 500){\ncount = 1;\na += 1;\nt += a;\ntt = t;\nfor(var i=0; i&#x3C;primeSieve.length; i++){\nif(primeSieve[i] * primeSieve[i] > tt){\ncount *= 2;\nbreak;\n}\nexponent = 1;\nwhile(tt % primeSieve[i] == 0){\nexponent++;\ntt = tt/primeSieve[i];\n}\nif(exponent > 1)\ncount = count * exponent;\nif(tt == 1)\nbreak;\n}\n}\nreturn t;\n}\n{% endhighlight %}</p>\n<p>Comparisons of runtimes:</p>\n<ol>\n<li>Original brute force: 663.8050000000001 ms<br/></li>\n<li>Improved with Atkin: 13.5 ms</li>\n</ol>\n<p>Can we get this better?</p>\n<p>Well we know that $$\\sum_{i=1}^{n}i = \\frac{n * (n+1)}{2}$$.</p>\n<p>We also know that <code class=\"language-text\">n</code> and <code class=\"language-text\">n+1</code> are coprime (no common prime factors). So the number of divisors may be represented as:</p>\n<ol>\n<li>$$D(t) = D(\\frac{n}{2}) * D(n+1)$$ if n is even</li>\n<li>$$D(t) = D(n) * D(\\frac{n+1}{2})$$ if (n+1) is even</li>\n</ol>\n<p>Sounds like if we’re dealing with the divisors themselves, it should be quicker than dealing with the larger triangle numbers. We can additionally use a smaller prime number for the sieve.</p>\n<p>{% highlight javascript %}\nfunction triangleImproved() {\nvar n = 3;\nvar Dn = 2;\nvar primeDivisors = 2;\nvar count = 0;\nvar n1, Dn1, i, exponent;\nvar primeSieve = sievePrimesAtkin(1000);\nwhile (count &#x3C;= 500) {\nn += 1;\nn1 = n;\nif (n1 % 2 === 0)\nn1 = n1 / 2;\nDn1 = 1;\nfor (var i = 0; i &#x3C; primeSieve.length; i++) {\nif (primeSieve[i] * primeSieve[i] > n1) {\nDn1 *= 2;\nbreak;\n}\nexponent = 1;\nwhile (n1 % primeSieve[i] === 0) {\nexponent++;\nn1 = n1 / primeSieve[i];\n}\nif (exponent > 1)\nDn1 = Dn1 * exponent;\nif (n1 == 1)\nbreak;\n}\ncount = Dn * Dn1;\nDn = Dn1;\n}\nreturn n * (n - 1) / 2;\n}\n{% endhighlight %}</p>\n<p>For this improved version we have an average runtime of: 1.43 ms, which appears to be more than 100x faster than our initial brute force attempt.</p>","frontmatter":{"title":"Let's Solve Project Euler Problem 12","date":"June 22, 2017","description":"Euler Problem 12"}}},"pageContext":{"slug":"/project-euler-12/","previous":{"fields":{"slug":"/project-euler-11/"},"frontmatter":{"title":"Let's Solve Project Euler Problem 11"}},"next":{"fields":{"slug":"/project-euler-13/"},"frontmatter":{"title":"Let's Solve Project Euler Problem 13"}}}},"staticQueryHashes":["1246554614","2841359383"]}